# Makefile para o projeto Genius360
.PHONY: all up down ps fix-server start exec shell logs rails-console db-console db-migrate db-reset server-status server-start server-stop server-restart help db-setup db-check fix-db-connection check-docker-network recreate-docker-network get-postgres-ip check-ports kill-port start-force find-free-port server-on-any-port server-status-detailed server-fix server-clean server-smart-start fix-all find-compose-file check-containers container-logs fix-container restart-all repair-web first-run bundle-install rebuild clean-all create-db-script

# Valor padrÃ£o para a porta
port ?= 3000

# VariÃ¡veis de ambiente - ajustado para procurar nos locais mais comuns
SCRIPTS_DIR = .scripts

# VerificaÃ§Ã£o para encontrar o arquivo docker-compose.yml
find-compose-file:
	@if [ -f "docker-compose.yml" ]; then \
		echo "docker-compose"; \
	elif [ -f ".docker/docker-compose.yml" ]; then \
		echo "docker-compose -f .docker/docker-compose.yml"; \
	elif [ -f "docker/docker-compose.yml" ]; then \
		echo "docker-compose -f docker/docker-compose.yml"; \
	else \
		echo "Erro: NÃ£o foi possÃ­vel encontrar o arquivo docker-compose.yml" >&2; \
		echo "Por favor, especifique o caminho correto no Makefile." >&2; \
		exit 1; \
	fi

# Usar o comando padrÃ£o do docker-compose sem referÃªncia explÃ­cita ao arquivo
DOCKER_COMPOSE = docker-compose

# Definir variÃ¡veis para scripts
SERVER_MANAGER = $(SCRIPTS_DIR)/manage_server.sh
FIX_SERVER = $(SCRIPTS_DIR)/fix_server.sh
DOCKER_DIAG = $(SCRIPTS_DIR)/docker_diagnostico.sh
RESTART_SERVICES = $(SCRIPTS_DIR)/restart_services.sh
CHECK_STATUS = $(SCRIPTS_DIR)/check_status.sh
PERFORMANCE_CHECK = $(SCRIPTS_DIR)/performance_check.sh

all:
	@echo "Comandos disponÃ­veis:"
	@echo "  make up           - Inicia os serviÃ§os em background"
	@echo "  make down         - Para todos os containers"
	@echo "  make ps           - Lista os containers em execuÃ§Ã£o"
	@echo "  make fix-server   - Corrige problema 'server already running'"
	@echo "  make start        - Inicia todos os serviÃ§os e abre shell no container"
	@echo "  make exec         - Inicia os containers e abre o console web"
	@echo "  make shell        - Abre o terminal no container web"
	@echo "  make logs         - Exibe os logs dos containers"
	@echo "  make rails-console- Abre o console Rails"
	@echo "  make db-console   - Abre o console PostgreSQL"
	@echo "  make db-migrate   - Executa migraÃ§Ãµes do banco de dados"
	@echo "  make db-reset     - Recria o banco de dados"
	@echo "  make db-setup     - Configura o banco de dados (cria usuÃ¡rio e configura senha)"
	@echo "  make db-check     - Verifica a conexÃ£o com o banco de dados"
	@echo "  make fix-db-connection - Resolve problemas de conexÃ£o com o banco de dados"
	@echo "  make check-docker-network - Verifica a rede Docker"
	@echo "  make recreate-docker-network - Recria a rede Docker"
	@echo "  make get-postgres-ip - ObtÃ©m o IP do container PostgreSQL"
	@echo "  make server-status- Verifica o status do servidor"
	@echo "  make server-start - Inicia o servidor na porta 3001"
	@echo "  make server-stop  - Para o servidor"
	@echo "  make server-restart- Reinicia o servidor na porta 3001"
	@echo "  make help         - Exibe os comandos disponÃ­veis"
	@echo "  make check-ports  - Verifica as portas em uso"
	@echo "  make kill-port    - Libera uma porta especÃ­fica"
	@echo "  make rebuild      - ReconstrÃ³i completamente o ambiente"
	@echo "  make clean-all    - Limpa todos os caches e dados"

check-ports:
	@echo "ğŸ” Verificando portas em uso..."
	@echo "ğŸ”¹ Porta 3000 (Rails):"
	@lsof -i :3000 || echo "âœ… Porta 3000 livre"
	@echo "ğŸ”¹ Porta 3001 (Rails alternativo):"
	@lsof -i :3001 || echo "âœ… Porta 3001 livre"
	@echo "ğŸ”¹ Porta 5432 (PostgreSQL original):"
	@lsof -i :5432 || echo "âœ… Porta 5432 livre"
	@echo "ğŸ”¹ Porta 5433 (PostgreSQL alternativo):"
	@lsof -i :5433 || echo "âœ… Porta 5433 livre"
	@echo "âœ¨ VerificaÃ§Ã£o de portas concluÃ­da"

kill-port:
	@if [ -z "$(port)" ]; then \
		echo "âš ï¸ Por favor, especifique uma porta: make kill-port port=5432"; \
	else \
		echo "ğŸ” Verificando processos usando a porta $(port)..."; \
		pid=$$(lsof -t -i:$(port)); \
		if [ -z "$$pid" ]; then \
			echo "âœ… Nenhum processo encontrado usando a porta $(port)"; \
		else \
			echo "ğŸ›‘ Finalizando processo(s) $$pid usando a porta $(port)..."; \
			for p in $$pid; do \
				kill -9 $$p; \
			done; \
			echo "âœ… Porta $(port) liberada!"; \
		fi; \
	fi

up:
	@echo "ğŸš€ Iniciando serviÃ§os..."
	@$(DOCKER_COMPOSE) up -d

down:
	@echo "ğŸ›‘ Parando serviÃ§os..."
	@$(DOCKER_COMPOSE) down

ps:
	@$(DOCKER_COMPOSE) ps

fix-server:
	@echo "ğŸ”§ Corrigindo problema de 'server already running'..."
	@$(DOCKER_COMPOSE) exec web bash -c "rm -f /app/tmp/pids/server.pid" || echo "âš ï¸ NÃ£o foi possÃ­vel remover o arquivo PID. Tentando outra abordagem..."
	@$(DOCKER_COMPOSE) exec web bash -c "if ps aux | grep -q '[p]uma'; then pkill -f puma; fi" || echo "âš ï¸ NÃ£o foi possÃ­vel encerrar processos Puma."
	@echo "âœ… Arquivo PID removido"

start:
	@echo "ğŸš€ Iniciando servidor Rails..."
	@chmod +x bin/port_manager.sh
	@bin/port_manager.sh $(port) || (echo "âš ï¸ Tentando com porta alternativa..." && bin/port_manager.sh 3002)
	@make server-stop

start-force:
	@$(DOCKER_COMPOSE) exec web bash -c "cd /app && rm -f tmp/pids/server.pid && ps aux | grep -q '[p]uma' && pkill -f puma || true"
	@echo "ğŸš€ Iniciando servidor Rails (modo forÃ§ado)..."
	@chmod +x bin/port_manager.sh
	@bin/port_manager.sh $(port) true
	@echo "âœ… Servidor Rails reiniciado completamente"

find-free-port:
	@echo "ğŸ” Procurando por uma porta livre..."
	@lsof -i :$(port) >/dev/null && echo "âŒ Porta $(port) estÃ¡ em uso." || echo "âœ… Porta $(port) estÃ¡ livre!"
	@make fix-server

server-on-any-port:
	@echo "ğŸš€ Iniciando servidor Rails em qualquer porta disponÃ­vel..."
	@for port in 3000 3001 3002 3003 3004 3005; do \
		echo "Tentando porta $$port..."; \
		if ! lsof -i :$$port >/dev/null 2>&1; then \
			echo "âœ… Porta $$port disponÃ­vel! Iniciando servidor..."; \
			make fix-server; \
			$(DOCKER_COMPOSE) exec web bash -c "cd /app && bundle exec rails s -p $$port -b '0.0.0.0' -d"; \
			echo "âœ… Servidor Rails iniciado na porta $$port"; \
			echo "ğŸŒ Acesse: http://localhost:$$port"; \
			exit 0; \
		fi; \
	done; \
	echo "âŒ NÃ£o foi possÃ­vel encontrar uma porta disponÃ­vel entre 3000-3005."

exec:
	@echo "ğŸš€ Iniciando ambiente Genius360..."
	@$(DOCKER_COMPOSE) up -d
	@echo "â³ Aguardando serviÃ§os..."
	@sleep 5
	@echo "ğŸ” Verificando status do container web..."
	@if docker ps | grep -q "genius360_web.*Up"; then \
		echo "âœ… Container web estÃ¡ rodando. Abrindo shell..."; \
		$(DOCKER_COMPOSE) exec web bash; \
	else \
		echo "âš ï¸ Container web nÃ£o estÃ¡ rodando corretamente."; \
		echo "ğŸ”§ Tentando reparo automÃ¡tico..."; \
		make repair-web; \
		echo "â³ Verificando novamente o status do container..."; \
		if docker ps | grep -q "genius360_web.*Up"; then \
			echo "âœ… Container reparado com sucesso. Tentando instalar dependÃªncias..."; \
			make bundle-install; \
			echo "â³ Abrindo shell..."; \
			$(DOCKER_COMPOSE) exec web bash; \
		else \
			echo "âŒ Falha ao reparar o container web."; \
			echo "Por favor, execute 'make container-logs container=web' para mais detalhes."; \
			exit 1; \
		fi; \
	fi

shell:
	@echo "ğŸš Abrindo terminal no container web..."
	@$(DOCKER_COMPOSE) exec web bash

logs:
	@$(DOCKER_COMPOSE) logs -f

rails-console:
	@echo "ğŸ›¤ï¸ Abrindo console Rails..."
	@$(DOCKER_COMPOSE) exec web rails console

db-console:
	@echo "ğŸ—„ï¸ Abrindo console PostgreSQL..."
	@$(DOCKER_COMPOSE) exec postgres psql -U postgres -d genius360_development

db-migrate:
	@echo "ğŸ”„ Executando migraÃ§Ãµes do banco de dados..."
	@$(DOCKER_COMPOSE) exec web rails db:migrate

db-reset:
	@echo "âš ï¸ Recriando banco de dados... âš ï¸"
	@$(DOCKER_COMPOSE) exec web rails db:drop db:create db:migrate db:seed

db-setup:
	@echo "ğŸ”§ Configurando banco de dados..."
	@mkdir -p $(SCRIPTS_DIR)/db
	@chmod +x $(SCRIPTS_DIR)/db/setup.sh || make create-db-script
	@$(SCRIPTS_DIR)/db/setup.sh

db-check:
	@echo "ğŸ” Verificando conexÃ£o com o banco de dados..."
	@$(DOCKER_COMPOSE) exec web bash -c "cd /app && bundle exec rails runner 'ActiveRecord::Base.connection; puts \"âœ… ConexÃ£o com o banco de dados estÃ¡ funcionando corretamente\"'" || echo "âŒ Falha na conexÃ£o com o banco de dados"

fix-db-connection:
	@echo "ğŸ”§ Resolvendo problemas de conexÃ£o com o banco de dados..."
	@make db-setup
	@echo "â³ Aguardando a aplicaÃ§Ã£o da configuraÃ§Ã£o..."
	@sleep 3
	@make db-check
	@echo "ğŸš€ Tente reiniciar o servidor agora com 'make server-restart'"

check-docker-network:
	@echo "ğŸ” Verificando rede Docker..."
	@mkdir -p $(SCRIPTS_DIR)
	@chmod +x $(DOCKER_DIAG) || echo "âš ï¸ Script $(DOCKER_DIAG) nÃ£o encontrado"
	@$(DOCKER_DIAG) || echo "âš ï¸ Falha ao executar diagnÃ³stico de rede Docker"

recreate-docker-network:
	@echo "ğŸ”„ Recriando rede Docker..."
	@$(DOCKER_COMPOSE) down
	@docker network prune -f
	@$(DOCKER_COMPOSE) up -d
	@echo "âœ… Rede Docker recriada. Aguarde alguns segundos..."
	@sleep 5
	@make check-docker-network

get-postgres-ip:
	@echo "ğŸ” Obtendo IP do container PostgreSQL..."
	@echo "IP: $(shell docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' genius360_postgres)"
	@echo "Para usar este IP, atualize seu config/database.yml com este valor no campo 'host'"

server-status:
	@echo "ğŸ” Verificando status do servidor Rails..."
	@mkdir -p $(SCRIPTS_DIR)
	@chmod +x $(CHECK_STATUS) || echo "âš ï¸ Script $(CHECK_STATUS) nÃ£o encontrado"
	@$(CHECK_STATUS) || echo "âš ï¸ Falha ao verificar status do servidor"

server-status-detailed:
	@echo "ğŸ” Verificando status detalhado do servidor Rails..."
	@chmod +x bin/rails_server_manager.sh || echo "âš ï¸ Script bin/rails_server_manager.sh nÃ£o encontrado"
	@$(DOCKER_COMPOSE) exec web /app/bin/rails_server_manager.sh status || echo "âš ï¸ Falha ao verificar status detalhado"
	@echo "âœ¨ VerificaÃ§Ã£o de status concluÃ­da"

server-start:
	@echo "ğŸš€ Iniciando servidor Rails na porta 3001..."
	@make fix-server
	@$(DOCKER_COMPOSE) exec web bash -c "cd /app && bundle exec rails s -p 3001 -b '0.0.0.0' -d"
	@echo "âœ… Servidor Rails iniciado na porta 3001"
	@echo "ğŸŒ Acesse: http://localhost:3001"

server-stop:
	@echo "ğŸ›‘ Parando servidor Rails..."
	@$(DOCKER_COMPOSE) exec web bash -c "rm -f /app/tmp/pids/server.pid"
	@echo "âœ… Servidor Rails parado"

server-restart:
	@echo "ğŸ”„ Reiniciando servidor Rails..."
	@mkdir -p $(SCRIPTS_DIR)
	@chmod +x $(RESTART_SERVICES) || echo "âš ï¸ Script $(RESTART_SERVICES) nÃ£o encontrado"
	@$(RESTART_SERVICES) || make server-stop && make server-start

server-fix:
	@echo "ğŸ”§ Corrigindo problemas do servidor Rails..."
	@mkdir -p $(SCRIPTS_DIR)
	@chmod +x $(FIX_SERVER) || echo "âš ï¸ Script $(FIX_SERVER) nÃ£o encontrado"
	@$(FIX_SERVER) || make fix-server

server-clean:
	@echo "ğŸ§¹ Limpando arquivos temporÃ¡rios do servidor..."
	@chmod +x bin/rails_server_manager.sh || echo "âš ï¸ Script bin/rails_server_manager.sh nÃ£o encontrado"
	@$(DOCKER_COMPOSE) exec web /app/bin/rails_server_manager.sh clean || echo "âš ï¸ Falha ao limpar arquivos temporÃ¡rios"
	@echo "âœ… Arquivos temporÃ¡rios limpos"

server-smart-start:
	@echo "ğŸš€ Iniciando servidor Rails inteligentemente..."
	@chmod +x bin/rails_server_manager.sh || echo "âš ï¸ Script bin/rails_server_manager.sh nÃ£o encontrado"
	@$(DOCKER_COMPOSE) exec web /app/bin/rails_server_manager.sh start $(port) || make server-start
	@echo "âœ¨ Comando de inicializaÃ§Ã£o executado"

fix-all:
	@echo "ğŸ”§ Corrigindo todos os problemas conhecidos..."
	@make down
	@mkdir -p $(SCRIPTS_DIR)
	@chmod +x $(SCRIPTS_DIR)/development_setup.sh || echo "âš ï¸ Script $(SCRIPTS_DIR)/development_setup.sh nÃ£o encontrado"
	@$(SCRIPTS_DIR)/development_setup.sh || echo "âš ï¸ Falha ao executar script de setup de desenvolvimento"
	@make up
	@make bundle-install
	@make db-setup
	@make server-fix
	@make server-clean
	@make server-smart-start port=3002
	@echo "âœ¨ Sistema corrigido e reiniciado"

check-containers:
	@echo "ğŸ” Verificando status dos containers..."
	@docker ps -a | grep genius360 || echo "âš ï¸ Nenhum container encontrado"
	@echo "âœ¨ Checagem concluÃ­da"

container-logs:
	@if [ -z "$(container)" ]; then \
		echo "âš ï¸ Por favor, especifique um container: make container-logs container=web"; \
		echo "Containers disponÃ­veis:"; \
		docker ps -a --format "{{.Names}}" | grep genius360; \
	else \
		echo "ğŸ“‹ Exibindo logs do container genius360_$(container)..."; \
		docker logs genius360_$(container); \
	fi

fix-container:
	@if [ -z "$(container)" ]; then \
		echo "âš ï¸ Por favor, especifique um container: make fix-container container=web"; \
	else \
		echo "ğŸ”§ Tentando corrigir problemas no container genius360_$(container)..."; \
		docker stop genius360_$(container) || true; \
		docker start genius360_$(container); \
		echo "â³ Aguardando inicializaÃ§Ã£o..."; \
		sleep 5; \
		docker ps -a | grep genius360_$(container); \
	fi

restart-all:
	@echo "ğŸ”„ Reiniciando todos os containers..."
	@$(DOCKER_COMPOSE) restart
	@echo "â³ Aguardando reinicializaÃ§Ã£o..."
	@sleep 10
	@$(DOCKER_COMPOSE) ps

repair-web:
	@echo "ğŸ”§ Iniciando reparo do container web..."
	@chmod +x bin/repair_web_container.sh || echo "âš ï¸ Script bin/repair_web_container.sh nÃ£o encontrado"
	@bin/repair_web_container.sh || echo "âš ï¸ Falha ao executar script de reparo"

bundle-install:
	@echo "ğŸ“¦ Instalando dependÃªncias do bundle..."
	@chmod +x bin/install_bundle.sh || echo "âš ï¸ Script bin/install_bundle.sh nÃ£o encontrado"
	@bin/install_bundle.sh || echo "âš ï¸ Falha ao executar bundle install"

first-run:
	@echo "ğŸš€ Configurando o ambiente para primeira execuÃ§Ã£o..."
	@chmod +x bin/fix_volume_mapping.sh || echo "âš ï¸ Script bin/fix_volume_mapping.sh nÃ£o encontrado"
	@bin/fix_volume_mapping.sh || echo "âš ï¸ Falha ao ajustar mapeamento de volumes"
	@make down
	@make create-db-script
	@make up
	@make bundle-install
	@make db-setup
	@echo "âœ¨ ConfiguraÃ§Ã£o inicial concluÃ­da!"
	@echo "ğŸŒŸ Agora vocÃª pode executar 'make exec' para abrir um shell no container."

# Comando para criar o script de setup do banco de dados
create-db-script:
	@echo "ğŸ“ Criando diretÃ³rio e script para setup do banco de dados..."
	@mkdir -p $(SCRIPTS_DIR)/db
	@cat > $(SCRIPTS_DIR)/db/setup.sh << 'EOF'
#!/bin/bash

# Script para configurar o banco de dados PostgreSQL

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "$${BLUE}ğŸ”§ Configurando banco de dados PostgreSQL...$${NC}"

# Verificar se o container postgres estÃ¡ rodando
if ! docker ps | grep -q "genius360_postgres"; then
    echo -e "$${YELLOW}âš ï¸ Container Postgres nÃ£o estÃ¡ rodando. Tentando iniciar...$${NC}"
    docker start genius360_postgres
    sleep 3
    
    if ! docker ps | grep -q "genius360_postgres"; then
        echo -e "$${RED}âŒ NÃ£o foi possÃ­vel iniciar o container Postgres. Verifique o docker-compose.$${NC}"
        exit 1
    fi
fi

echo -e "$${BLUE}ğŸ” Verificando conexÃ£o com o banco de dados...$${NC}"

# Verificar se jÃ¡ Ã© possÃ­vel conectar ao banco
if docker exec genius360_postgres psql -U postgres -c '\l' > /dev/null 2>&1; then
    echo -e "$${GREEN}âœ… ConexÃ£o com PostgreSQL estabelecida!$${NC}"
else
    echo -e "$${YELLOW}âš ï¸ Aguardando PostgreSQL iniciar completamente...$${NC}"
    sleep 5
fi

echo -e "$${BLUE}ğŸ”§ Criando banco de dados e usuÃ¡rio...$${NC}"

# Criar usuÃ¡rio se nÃ£o existir
docker exec genius360_postgres psql -U postgres -c "SELECT 1 FROM pg_roles WHERE rolname='postgres'" | grep -q 1 || docker exec genius360_postgres psql -U postgres -c "CREATE USER postgres WITH SUPERUSER PASSWORD 'postgres';"

# Criar banco de dados de desenvolvimento
docker exec genius360_postgres psql -U postgres -c "SELECT 1 FROM pg_database WHERE datname='genius360_development'" | grep -q 1 || docker exec genius360_postgres psql -U postgres -c "CREATE DATABASE genius360_development OWNER postgres;"

# Criar banco de dados de teste
docker exec genius360_postgres psql -U postgres -c "SELECT 1 FROM pg_database WHERE datname='genius360_test'" | grep -q 1 || docker exec genius360_postgres psql -U postgres -c "CREATE DATABASE genius360_test OWNER postgres;"

echo -e "$${BLUE}ğŸ”§ Configurando permissÃµes...$${NC}"

# Conceder todos os privilÃ©gios nos bancos para o usuÃ¡rio
docker exec genius360_postgres psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE genius360_development TO postgres;"
docker exec genius360_postgres psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE genius360_test TO postgres;"

echo -e "$${GREEN}âœ… ConfiguraÃ§Ã£o do banco de dados concluÃ­da!$${NC}"

# Verificar se o container web estÃ¡ rodando
if docker ps | grep -q "genius360_web"; then
    echo -e "$${BLUE}ğŸ”§ Atualizando arquivo database.yml no container web...$${NC}"
    
    # Verificar se o arquivo database.yml existe e atualizÃ¡-lo
    docker exec genius360_web bash -c "if [ -f /app/config/database.yml ]; then \\
        sed -i 's/host: .*/host: postgres/' /app/config/database.yml; \\
        sed -i 's/username: .*/username: postgres/' /app/config/database.yml; \\
        sed -i 's/password: .*/password: postgres/' /app/config/database.yml; \\
        echo 'âœ… Arquivo database.yml atualizado!'; \\
    else \\
        echo 'âš ï¸ Arquivo database.yml nÃ£o encontrado. Ã‰ necessÃ¡rio criÃ¡-lo manualmente.'; \\
    fi"
    
    # Criar o arquivo database.yml se nÃ£o existir
    docker exec genius360_web bash -c "if [ ! -f /app/config/database.yml ]; then \\
        mkdir -p /app/config; \\
        echo 'default: &default' > /app/config/database.yml; \\
        echo '  adapter: postgresql' >> /app/config/database.yml; \\
        echo '  encoding: unicode' >> /app/config/database.yml; \\
        echo '  pool: <%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %>' >> /app/config/database.yml; \\
        echo '  host: postgres' >> /app/config/database.yml; \\
        echo '  username: postgres' >> /app/config/database.yml; \\
        echo '  password: postgres' >> /app/config/database.yml; \\
        echo '' >> /app/config/database.yml; \\
        echo 'development:' >> /app/config/database.yml; \\
        echo '  <<: *default' >> /app/config/database.yml; \\
        echo '  database: genius360_development' >> /app/config/database.yml; \\
        echo '' >> /app/config/database.yml; \\
        echo 'test:' >> /app/config/database.yml; \\
        echo '  <<: *default' >> /app/config/database.yml; \\
        echo '  database: genius360_test' >> /app/config/database.yml; \\
        echo '' >> /app/config/database.yml; \\
        echo 'production:' >> /app/config/database.yml; \\
        echo '  <<: *default' >> /app/config/database.yml; \\
        echo '  database: genius360_production' >> /app/config/database.yml; \\
        echo 'âœ… Arquivo database.yml criado!'; \\
    fi"
    
    echo -e "$${GREEN}âœ… ConfiguraÃ§Ã£o do database.yml concluÃ­da!$${NC}"
fi

echo -e "$${GREEN}âœ… Banco de dados configurado com sucesso!$${NC}"
EOF
	@chmod +x $(SCRIPTS_DIR)/db/setup.sh
	@echo "âœ… Script de setup do banco de dados criado em $(SCRIPTS_DIR)/db/setup.sh"

# Comando para limpar todos os caches e dados
clean-all:
	@echo "ğŸ§¹ Limpando todos os caches e dados..."
	@$(DOCKER_COMPOSE) down -v || true
	@echo "ğŸ—‘ï¸ Removendo arquivos temporÃ¡rios..."
	@rm -rf tmp/* log/* .bundle vendor/bundle 2>/dev/null || true
	@echo "ğŸ—‘ï¸ Removendo volumes Docker..."
	@docker volume rm $(shell docker volume ls -q | grep genius360) 2>/dev/null || true
	@echo "ğŸ§¹ Limpando cache do Docker..."
	@docker builder prune -f || true
	@echo "âœ… Limpeza concluÃ­da!"

# Comando para reconstruir completamente o ambiente
rebuild:
	@echo "ğŸ”¨ Reconstruindo completamente o ambiente..."
	@make clean-all
	@echo "ğŸ”¨ Criando scripts necessÃ¡rios..."
	@make create-db-script
	@echo "ğŸ”¨ Reconstruindo containers..."
	@$(DOCKER_COMPOSE) build --no-cache || echo "âš ï¸ Falha ao reconstruir containers"
	@make up
	@make bundle-install
	@echo "ğŸ”¨ Configurando o banco de dados..."
	@make db-setup
	@echo "âœ… ReconstruÃ§Ã£o completa concluÃ­da!"
	@echo "ğŸŒŸ Agora vocÃª pode executar 'make exec' para abrir um shell no container."

help:
	@echo "Comandos disponÃ­veis:"
	@echo "  make start           - Inicia o servidor Rails na porta padrÃ£o (3000) ou verifica conflitos"
	@echo "  make start port=3001 - Inicia o servidor Rails na porta especÃ­fica indicada"
	@echo "  make check-ports     - Verifica as portas em uso"
	@echo "  make kill-port       - Libera uma porta especÃ­fica"
	@echo "  make repair-web      - Repara problemas no container web"
	@echo "  make check-containers- Verifica o status dos containers"
	@echo "  make container-logs container=web - Exibe logs de um container especÃ­fico"
	@echo "  make bundle-install  - Instala as dependÃªncias do bundle"
	@echo "  make first-run       - Configura o ambiente para primeira execuÃ§Ã£o"
	@echo "  make rebuild         - ReconstrÃ³i completamente o ambiente (limpa cache e dados)"
	@echo "  make clean-all       - Limpa todos os caches e dados"